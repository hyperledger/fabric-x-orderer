// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"

	"github.ibm.com/decentralized-trust-research/arma/common/types"
	"github.ibm.com/decentralized-trust-research/arma/core"
)

type FakeBatchAttestationFragment struct {
	DeserializeStub        func([]byte) error
	deserializeMutex       sync.RWMutex
	deserializeArgsForCall []struct {
		arg1 []byte
	}
	deserializeReturns struct {
		result1 error
	}
	deserializeReturnsOnCall map[int]struct {
		result1 error
	}
	DigestStub        func() []byte
	digestMutex       sync.RWMutex
	digestArgsForCall []struct {
	}
	digestReturns struct {
		result1 []byte
	}
	digestReturnsOnCall map[int]struct {
		result1 []byte
	}
	EpochStub        func() int64
	epochMutex       sync.RWMutex
	epochArgsForCall []struct {
	}
	epochReturns struct {
		result1 int64
	}
	epochReturnsOnCall map[int]struct {
		result1 int64
	}
	GarbageCollectStub        func() [][]byte
	garbageCollectMutex       sync.RWMutex
	garbageCollectArgsForCall []struct {
	}
	garbageCollectReturns struct {
		result1 [][]byte
	}
	garbageCollectReturnsOnCall map[int]struct {
		result1 [][]byte
	}
	PrimaryStub        func() types.PartyID
	primaryMutex       sync.RWMutex
	primaryArgsForCall []struct {
	}
	primaryReturns struct {
		result1 types.PartyID
	}
	primaryReturnsOnCall map[int]struct {
		result1 types.PartyID
	}
	SeqStub        func() types.BatchSequence
	seqMutex       sync.RWMutex
	seqArgsForCall []struct {
	}
	seqReturns struct {
		result1 types.BatchSequence
	}
	seqReturnsOnCall map[int]struct {
		result1 types.BatchSequence
	}
	SerializeStub        func() []byte
	serializeMutex       sync.RWMutex
	serializeArgsForCall []struct {
	}
	serializeReturns struct {
		result1 []byte
	}
	serializeReturnsOnCall map[int]struct {
		result1 []byte
	}
	ShardStub        func() types.ShardID
	shardMutex       sync.RWMutex
	shardArgsForCall []struct {
	}
	shardReturns struct {
		result1 types.ShardID
	}
	shardReturnsOnCall map[int]struct {
		result1 types.ShardID
	}
	SignatureStub        func() []byte
	signatureMutex       sync.RWMutex
	signatureArgsForCall []struct {
	}
	signatureReturns struct {
		result1 []byte
	}
	signatureReturnsOnCall map[int]struct {
		result1 []byte
	}
	SignerStub        func() types.PartyID
	signerMutex       sync.RWMutex
	signerArgsForCall []struct {
	}
	signerReturns struct {
		result1 types.PartyID
	}
	signerReturnsOnCall map[int]struct {
		result1 types.PartyID
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeBatchAttestationFragment) Deserialize(arg1 []byte) error {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.deserializeMutex.Lock()
	ret, specificReturn := fake.deserializeReturnsOnCall[len(fake.deserializeArgsForCall)]
	fake.deserializeArgsForCall = append(fake.deserializeArgsForCall, struct {
		arg1 []byte
	}{arg1Copy})
	stub := fake.DeserializeStub
	fakeReturns := fake.deserializeReturns
	fake.recordInvocation("Deserialize", []interface{}{arg1Copy})
	fake.deserializeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBatchAttestationFragment) DeserializeCallCount() int {
	fake.deserializeMutex.RLock()
	defer fake.deserializeMutex.RUnlock()
	return len(fake.deserializeArgsForCall)
}

func (fake *FakeBatchAttestationFragment) DeserializeCalls(stub func([]byte) error) {
	fake.deserializeMutex.Lock()
	defer fake.deserializeMutex.Unlock()
	fake.DeserializeStub = stub
}

func (fake *FakeBatchAttestationFragment) DeserializeArgsForCall(i int) []byte {
	fake.deserializeMutex.RLock()
	defer fake.deserializeMutex.RUnlock()
	argsForCall := fake.deserializeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBatchAttestationFragment) DeserializeReturns(result1 error) {
	fake.deserializeMutex.Lock()
	defer fake.deserializeMutex.Unlock()
	fake.DeserializeStub = nil
	fake.deserializeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBatchAttestationFragment) DeserializeReturnsOnCall(i int, result1 error) {
	fake.deserializeMutex.Lock()
	defer fake.deserializeMutex.Unlock()
	fake.DeserializeStub = nil
	if fake.deserializeReturnsOnCall == nil {
		fake.deserializeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deserializeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBatchAttestationFragment) Digest() []byte {
	fake.digestMutex.Lock()
	ret, specificReturn := fake.digestReturnsOnCall[len(fake.digestArgsForCall)]
	fake.digestArgsForCall = append(fake.digestArgsForCall, struct {
	}{})
	stub := fake.DigestStub
	fakeReturns := fake.digestReturns
	fake.recordInvocation("Digest", []interface{}{})
	fake.digestMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBatchAttestationFragment) DigestCallCount() int {
	fake.digestMutex.RLock()
	defer fake.digestMutex.RUnlock()
	return len(fake.digestArgsForCall)
}

func (fake *FakeBatchAttestationFragment) DigestCalls(stub func() []byte) {
	fake.digestMutex.Lock()
	defer fake.digestMutex.Unlock()
	fake.DigestStub = stub
}

func (fake *FakeBatchAttestationFragment) DigestReturns(result1 []byte) {
	fake.digestMutex.Lock()
	defer fake.digestMutex.Unlock()
	fake.DigestStub = nil
	fake.digestReturns = struct {
		result1 []byte
	}{result1}
}

func (fake *FakeBatchAttestationFragment) DigestReturnsOnCall(i int, result1 []byte) {
	fake.digestMutex.Lock()
	defer fake.digestMutex.Unlock()
	fake.DigestStub = nil
	if fake.digestReturnsOnCall == nil {
		fake.digestReturnsOnCall = make(map[int]struct {
			result1 []byte
		})
	}
	fake.digestReturnsOnCall[i] = struct {
		result1 []byte
	}{result1}
}

func (fake *FakeBatchAttestationFragment) Epoch() int64 {
	fake.epochMutex.Lock()
	ret, specificReturn := fake.epochReturnsOnCall[len(fake.epochArgsForCall)]
	fake.epochArgsForCall = append(fake.epochArgsForCall, struct {
	}{})
	stub := fake.EpochStub
	fakeReturns := fake.epochReturns
	fake.recordInvocation("Epoch", []interface{}{})
	fake.epochMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBatchAttestationFragment) EpochCallCount() int {
	fake.epochMutex.RLock()
	defer fake.epochMutex.RUnlock()
	return len(fake.epochArgsForCall)
}

func (fake *FakeBatchAttestationFragment) EpochCalls(stub func() int64) {
	fake.epochMutex.Lock()
	defer fake.epochMutex.Unlock()
	fake.EpochStub = stub
}

func (fake *FakeBatchAttestationFragment) EpochReturns(result1 int64) {
	fake.epochMutex.Lock()
	defer fake.epochMutex.Unlock()
	fake.EpochStub = nil
	fake.epochReturns = struct {
		result1 int64
	}{result1}
}

func (fake *FakeBatchAttestationFragment) EpochReturnsOnCall(i int, result1 int64) {
	fake.epochMutex.Lock()
	defer fake.epochMutex.Unlock()
	fake.EpochStub = nil
	if fake.epochReturnsOnCall == nil {
		fake.epochReturnsOnCall = make(map[int]struct {
			result1 int64
		})
	}
	fake.epochReturnsOnCall[i] = struct {
		result1 int64
	}{result1}
}

func (fake *FakeBatchAttestationFragment) GarbageCollect() [][]byte {
	fake.garbageCollectMutex.Lock()
	ret, specificReturn := fake.garbageCollectReturnsOnCall[len(fake.garbageCollectArgsForCall)]
	fake.garbageCollectArgsForCall = append(fake.garbageCollectArgsForCall, struct {
	}{})
	stub := fake.GarbageCollectStub
	fakeReturns := fake.garbageCollectReturns
	fake.recordInvocation("GarbageCollect", []interface{}{})
	fake.garbageCollectMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBatchAttestationFragment) GarbageCollectCallCount() int {
	fake.garbageCollectMutex.RLock()
	defer fake.garbageCollectMutex.RUnlock()
	return len(fake.garbageCollectArgsForCall)
}

func (fake *FakeBatchAttestationFragment) GarbageCollectCalls(stub func() [][]byte) {
	fake.garbageCollectMutex.Lock()
	defer fake.garbageCollectMutex.Unlock()
	fake.GarbageCollectStub = stub
}

func (fake *FakeBatchAttestationFragment) GarbageCollectReturns(result1 [][]byte) {
	fake.garbageCollectMutex.Lock()
	defer fake.garbageCollectMutex.Unlock()
	fake.GarbageCollectStub = nil
	fake.garbageCollectReturns = struct {
		result1 [][]byte
	}{result1}
}

func (fake *FakeBatchAttestationFragment) GarbageCollectReturnsOnCall(i int, result1 [][]byte) {
	fake.garbageCollectMutex.Lock()
	defer fake.garbageCollectMutex.Unlock()
	fake.GarbageCollectStub = nil
	if fake.garbageCollectReturnsOnCall == nil {
		fake.garbageCollectReturnsOnCall = make(map[int]struct {
			result1 [][]byte
		})
	}
	fake.garbageCollectReturnsOnCall[i] = struct {
		result1 [][]byte
	}{result1}
}

func (fake *FakeBatchAttestationFragment) Primary() types.PartyID {
	fake.primaryMutex.Lock()
	ret, specificReturn := fake.primaryReturnsOnCall[len(fake.primaryArgsForCall)]
	fake.primaryArgsForCall = append(fake.primaryArgsForCall, struct {
	}{})
	stub := fake.PrimaryStub
	fakeReturns := fake.primaryReturns
	fake.recordInvocation("Primary", []interface{}{})
	fake.primaryMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBatchAttestationFragment) PrimaryCallCount() int {
	fake.primaryMutex.RLock()
	defer fake.primaryMutex.RUnlock()
	return len(fake.primaryArgsForCall)
}

func (fake *FakeBatchAttestationFragment) PrimaryCalls(stub func() types.PartyID) {
	fake.primaryMutex.Lock()
	defer fake.primaryMutex.Unlock()
	fake.PrimaryStub = stub
}

func (fake *FakeBatchAttestationFragment) PrimaryReturns(result1 types.PartyID) {
	fake.primaryMutex.Lock()
	defer fake.primaryMutex.Unlock()
	fake.PrimaryStub = nil
	fake.primaryReturns = struct {
		result1 types.PartyID
	}{result1}
}

func (fake *FakeBatchAttestationFragment) PrimaryReturnsOnCall(i int, result1 types.PartyID) {
	fake.primaryMutex.Lock()
	defer fake.primaryMutex.Unlock()
	fake.PrimaryStub = nil
	if fake.primaryReturnsOnCall == nil {
		fake.primaryReturnsOnCall = make(map[int]struct {
			result1 types.PartyID
		})
	}
	fake.primaryReturnsOnCall[i] = struct {
		result1 types.PartyID
	}{result1}
}

func (fake *FakeBatchAttestationFragment) Seq() types.BatchSequence {
	fake.seqMutex.Lock()
	ret, specificReturn := fake.seqReturnsOnCall[len(fake.seqArgsForCall)]
	fake.seqArgsForCall = append(fake.seqArgsForCall, struct {
	}{})
	stub := fake.SeqStub
	fakeReturns := fake.seqReturns
	fake.recordInvocation("Seq", []interface{}{})
	fake.seqMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBatchAttestationFragment) SeqCallCount() int {
	fake.seqMutex.RLock()
	defer fake.seqMutex.RUnlock()
	return len(fake.seqArgsForCall)
}

func (fake *FakeBatchAttestationFragment) SeqCalls(stub func() types.BatchSequence) {
	fake.seqMutex.Lock()
	defer fake.seqMutex.Unlock()
	fake.SeqStub = stub
}

func (fake *FakeBatchAttestationFragment) SeqReturns(result1 types.BatchSequence) {
	fake.seqMutex.Lock()
	defer fake.seqMutex.Unlock()
	fake.SeqStub = nil
	fake.seqReturns = struct {
		result1 types.BatchSequence
	}{result1}
}

func (fake *FakeBatchAttestationFragment) SeqReturnsOnCall(i int, result1 types.BatchSequence) {
	fake.seqMutex.Lock()
	defer fake.seqMutex.Unlock()
	fake.SeqStub = nil
	if fake.seqReturnsOnCall == nil {
		fake.seqReturnsOnCall = make(map[int]struct {
			result1 types.BatchSequence
		})
	}
	fake.seqReturnsOnCall[i] = struct {
		result1 types.BatchSequence
	}{result1}
}

func (fake *FakeBatchAttestationFragment) Serialize() []byte {
	fake.serializeMutex.Lock()
	ret, specificReturn := fake.serializeReturnsOnCall[len(fake.serializeArgsForCall)]
	fake.serializeArgsForCall = append(fake.serializeArgsForCall, struct {
	}{})
	stub := fake.SerializeStub
	fakeReturns := fake.serializeReturns
	fake.recordInvocation("Serialize", []interface{}{})
	fake.serializeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBatchAttestationFragment) SerializeCallCount() int {
	fake.serializeMutex.RLock()
	defer fake.serializeMutex.RUnlock()
	return len(fake.serializeArgsForCall)
}

func (fake *FakeBatchAttestationFragment) SerializeCalls(stub func() []byte) {
	fake.serializeMutex.Lock()
	defer fake.serializeMutex.Unlock()
	fake.SerializeStub = stub
}

func (fake *FakeBatchAttestationFragment) SerializeReturns(result1 []byte) {
	fake.serializeMutex.Lock()
	defer fake.serializeMutex.Unlock()
	fake.SerializeStub = nil
	fake.serializeReturns = struct {
		result1 []byte
	}{result1}
}

func (fake *FakeBatchAttestationFragment) SerializeReturnsOnCall(i int, result1 []byte) {
	fake.serializeMutex.Lock()
	defer fake.serializeMutex.Unlock()
	fake.SerializeStub = nil
	if fake.serializeReturnsOnCall == nil {
		fake.serializeReturnsOnCall = make(map[int]struct {
			result1 []byte
		})
	}
	fake.serializeReturnsOnCall[i] = struct {
		result1 []byte
	}{result1}
}

func (fake *FakeBatchAttestationFragment) Shard() types.ShardID {
	fake.shardMutex.Lock()
	ret, specificReturn := fake.shardReturnsOnCall[len(fake.shardArgsForCall)]
	fake.shardArgsForCall = append(fake.shardArgsForCall, struct {
	}{})
	stub := fake.ShardStub
	fakeReturns := fake.shardReturns
	fake.recordInvocation("Shard", []interface{}{})
	fake.shardMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBatchAttestationFragment) ShardCallCount() int {
	fake.shardMutex.RLock()
	defer fake.shardMutex.RUnlock()
	return len(fake.shardArgsForCall)
}

func (fake *FakeBatchAttestationFragment) ShardCalls(stub func() types.ShardID) {
	fake.shardMutex.Lock()
	defer fake.shardMutex.Unlock()
	fake.ShardStub = stub
}

func (fake *FakeBatchAttestationFragment) ShardReturns(result1 types.ShardID) {
	fake.shardMutex.Lock()
	defer fake.shardMutex.Unlock()
	fake.ShardStub = nil
	fake.shardReturns = struct {
		result1 types.ShardID
	}{result1}
}

func (fake *FakeBatchAttestationFragment) ShardReturnsOnCall(i int, result1 types.ShardID) {
	fake.shardMutex.Lock()
	defer fake.shardMutex.Unlock()
	fake.ShardStub = nil
	if fake.shardReturnsOnCall == nil {
		fake.shardReturnsOnCall = make(map[int]struct {
			result1 types.ShardID
		})
	}
	fake.shardReturnsOnCall[i] = struct {
		result1 types.ShardID
	}{result1}
}

func (fake *FakeBatchAttestationFragment) Signature() []byte {
	fake.signatureMutex.Lock()
	ret, specificReturn := fake.signatureReturnsOnCall[len(fake.signatureArgsForCall)]
	fake.signatureArgsForCall = append(fake.signatureArgsForCall, struct {
	}{})
	stub := fake.SignatureStub
	fakeReturns := fake.signatureReturns
	fake.recordInvocation("Signature", []interface{}{})
	fake.signatureMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBatchAttestationFragment) SignatureCallCount() int {
	fake.signatureMutex.RLock()
	defer fake.signatureMutex.RUnlock()
	return len(fake.signatureArgsForCall)
}

func (fake *FakeBatchAttestationFragment) SignatureCalls(stub func() []byte) {
	fake.signatureMutex.Lock()
	defer fake.signatureMutex.Unlock()
	fake.SignatureStub = stub
}

func (fake *FakeBatchAttestationFragment) SignatureReturns(result1 []byte) {
	fake.signatureMutex.Lock()
	defer fake.signatureMutex.Unlock()
	fake.SignatureStub = nil
	fake.signatureReturns = struct {
		result1 []byte
	}{result1}
}

func (fake *FakeBatchAttestationFragment) SignatureReturnsOnCall(i int, result1 []byte) {
	fake.signatureMutex.Lock()
	defer fake.signatureMutex.Unlock()
	fake.SignatureStub = nil
	if fake.signatureReturnsOnCall == nil {
		fake.signatureReturnsOnCall = make(map[int]struct {
			result1 []byte
		})
	}
	fake.signatureReturnsOnCall[i] = struct {
		result1 []byte
	}{result1}
}

func (fake *FakeBatchAttestationFragment) Signer() types.PartyID {
	fake.signerMutex.Lock()
	ret, specificReturn := fake.signerReturnsOnCall[len(fake.signerArgsForCall)]
	fake.signerArgsForCall = append(fake.signerArgsForCall, struct {
	}{})
	stub := fake.SignerStub
	fakeReturns := fake.signerReturns
	fake.recordInvocation("Signer", []interface{}{})
	fake.signerMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBatchAttestationFragment) SignerCallCount() int {
	fake.signerMutex.RLock()
	defer fake.signerMutex.RUnlock()
	return len(fake.signerArgsForCall)
}

func (fake *FakeBatchAttestationFragment) SignerCalls(stub func() types.PartyID) {
	fake.signerMutex.Lock()
	defer fake.signerMutex.Unlock()
	fake.SignerStub = stub
}

func (fake *FakeBatchAttestationFragment) SignerReturns(result1 types.PartyID) {
	fake.signerMutex.Lock()
	defer fake.signerMutex.Unlock()
	fake.SignerStub = nil
	fake.signerReturns = struct {
		result1 types.PartyID
	}{result1}
}

func (fake *FakeBatchAttestationFragment) SignerReturnsOnCall(i int, result1 types.PartyID) {
	fake.signerMutex.Lock()
	defer fake.signerMutex.Unlock()
	fake.SignerStub = nil
	if fake.signerReturnsOnCall == nil {
		fake.signerReturnsOnCall = make(map[int]struct {
			result1 types.PartyID
		})
	}
	fake.signerReturnsOnCall[i] = struct {
		result1 types.PartyID
	}{result1}
}

func (fake *FakeBatchAttestationFragment) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.deserializeMutex.RLock()
	defer fake.deserializeMutex.RUnlock()
	fake.digestMutex.RLock()
	defer fake.digestMutex.RUnlock()
	fake.epochMutex.RLock()
	defer fake.epochMutex.RUnlock()
	fake.garbageCollectMutex.RLock()
	defer fake.garbageCollectMutex.RUnlock()
	fake.primaryMutex.RLock()
	defer fake.primaryMutex.RUnlock()
	fake.seqMutex.RLock()
	defer fake.seqMutex.RUnlock()
	fake.serializeMutex.RLock()
	defer fake.serializeMutex.RUnlock()
	fake.shardMutex.RLock()
	defer fake.shardMutex.RUnlock()
	fake.signatureMutex.RLock()
	defer fake.signatureMutex.RUnlock()
	fake.signerMutex.RLock()
	defer fake.signerMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeBatchAttestationFragment) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ core.BatchAttestationFragment = new(FakeBatchAttestationFragment)

/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package ledger

import (
	"fmt"

	"github.ibm.com/decentralized-trust-research/arma/common/ledger/blkstorage"
	"github.ibm.com/decentralized-trust-research/arma/common/ledger/blockledger"
	"github.ibm.com/decentralized-trust-research/arma/common/ledger/blockledger/fileledger"
	"github.ibm.com/decentralized-trust-research/arma/common/types"
	"github.ibm.com/decentralized-trust-research/arma/core"

	"github.com/hyperledger/fabric-protos-go-apiv2/common"
	"github.com/hyperledger/fabric/protoutil"
	"github.com/pkg/errors"
)

// BatchLedgerPart holds batches generated by a single party when said party was a primary.
// Batches are encoded in a Fabric block.
// The BatchLedgerPart for shard=A and party=B (where A,B are int) is stored in ledger that belongs to
// channel name "shardApartyB".
type BatchLedgerPart struct {
	shardID        types.ShardID          // The shard this object belongs to.
	partyID        types.PartyID          // The party that operates this object.
	primaryPartyID types.PartyID          // The primary party that generated the batches in this object.
	ledger         blockledger.ReadWriter // The fabric block ledger that holds batches.
	prevHash       []byte                 // The header hash of the last block; we need this because the Fabric ledger enforces a hash chain.
	logger         types.Logger
}

// newBatchLedgerPart creates a new BatchLedgerPart.
func newBatchLedgerPart(
	provider *blkstorage.BlockStoreProvider,
	shardID types.ShardID,
	partyID, primaryPartyID types.PartyID,
	logger types.Logger,
) (*BatchLedgerPart, error) {
	name := fmt.Sprintf("shard%dparty%d", shardID, primaryPartyID)
	ledger, err := provider.Open(name)
	if err != nil {
		return nil, err
	}
	fl := fileledger.NewFileLedger(ledger)
	part := &BatchLedgerPart{
		shardID:        shardID,
		partyID:        partyID,
		primaryPartyID: primaryPartyID,
		ledger:         fl,
		prevHash:       nil,
		logger:         logger,
	}

	// compute prev hash
	h := fl.Height()
	if h > 0 {
		block, err := fl.RetrieveBlockByNumber(h - 1)
		if err != nil {
			return nil, errors.Errorf("failed retrieving last block: %v", err)
		}
		part.prevHash = protoutil.BlockHeaderHash(block.Header)
	}

	return part, nil
}

// Append adds a batch to the end of the ledger chain.
// The `seq` must match the expected block number (i.e. Height()).
func (b *BatchLedgerPart) Append(seq types.BatchSequence, batchedRequests types.BatchedRequests) {
	b.logger.Debugf("Party %d, Shard: %d, is appending batch with sequence %d of size %d bytes, from Primary: %d", b.partyID, b.shardID, seq, batchedRequests.SizeBytes(), b.primaryPartyID)

	block, _ := NewFabricBatchFromRequests(b.primaryPartyID, b.shardID, seq, batchedRequests, b.prevHash)

	// Note: We do this only because we reuse the Fabric ledger, we don't really need a hash chain here.
	b.prevHash = protoutil.BlockHeaderHash(block.Header)

	if err := b.ledger.Append((*common.Block)(block)); err != nil {
		panic(err)
	}
}

// Height returns the number of batches in the ledger.
func (b *BatchLedgerPart) Height() uint64 {
	return b.ledger.Height()
}

// RetrieveBatchByNumber retrieves the batch with a specific sequence, or returns nil if not found.
func (b *BatchLedgerPart) RetrieveBatchByNumber(seq uint64) core.Batch {
	block, err := b.ledger.RetrieveBlockByNumber(seq)
	if err != nil {
		b.logger.Errorf("Batch not found: %d, err: %s", seq, err)
		return nil
	}

	return (*FabricBatch)(block)
}

// Ledger returns the underlying ledger, which supports an iterator as well.
func (b *BatchLedgerPart) Ledger() blockledger.ReadWriter {
	return b.ledger
}
